#!/usr/bin/env python3
"""Send email/Discord notifications for daily picks."""

import os
import sys
import json
from pathlib import Path
from datetime import datetime
import logging

sys.path.insert(0, str(Path(__file__).parent.parent))

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)


def send_email_notification(picks_file: str, email: str = None):
    """Send email notification with picks."""
    if not email:
        email = os.getenv("NOTIFICATION_EMAIL")
    
    if not email:
        logger.warning("No email configured. Set NOTIFICATION_EMAIL env var.")
        return False
    
    # Load picks
    with open(picks_file) as f:
        picks_data = json.load(f)
    
    picks = picks_data.get('picks', [])
    
    # Format email body
    subject = f"NFL Picks - {datetime.now().strftime('%Y-%m-%d')} ({len(picks)} picks)"
    
    body = f"""
NFL BETTING PICKS - {datetime.now().strftime('%Y-%m-%d %H:%M')}
{'='*60}

Bankroll: ${picks_data.get('bankroll', 0):,.0f}
Total Picks: {len(picks)}

"""
    
    for i, pick in enumerate(picks, 1):
        body += f"""
[{pick.get('tier', '?')}-TIER] {pick.get('game', 'Unknown')}
  Pick: {pick.get('pick', 'N/A')} {pick.get('line', 'N/A')}
  Book: {pick.get('best_book', 'N/A')}
  Edge: {pick.get('edge', 'N/A')}
  Bet: {pick.get('bet_size', 'N/A')} ({pick.get('bet_size_pct', 'N/A')})
  
"""
    
    body += "\n" + "="*60 + "\n"
    body += "Generated by NFL Betting System\n"
    
    # Send email (requires SMTP config)
    logger.info(f"Email notification prepared for {email}")
    logger.info("Configure SMTP settings to actually send emails")
    
    return True


def send_discord_notification(picks_file: str, webhook_url: str = None):
    """Send Discord notification via webhook."""
    import requests
    
    if not webhook_url:
        webhook_url = os.getenv("DISCORD_WEBHOOK_URL")
    
    if not webhook_url:
        logger.warning("No Discord webhook configured. Set DISCORD_WEBHOOK_URL env var.")
        return False
    
    # Load picks
    with open(picks_file) as f:
        picks_data = json.load(f)
    
    picks = picks_data.get('picks', [])
    
    # Format Discord message
    message = {
        "content": f"**NFL Picks - {datetime.now().strftime('%Y-%m-%d')}** ({len(picks)} picks)",
        "embeds": []
    }
    
    for pick in picks[:10]:  # Discord limit
        embed = {
            "title": f"{pick.get('tier', '?')}-Tier: {pick.get('game', 'Unknown')}",
            "description": f"**Pick:** {pick.get('pick', 'N/A')} {pick.get('line', 'N/A')}\n"
                          f"**Book:** {pick.get('best_book', 'N/A')}\n"
                          f"**Edge:** {pick.get('edge', 'N/A')}\n"
                          f"**Bet:** {pick.get('bet_size', 'N/A')}",
            "color": 0x00ff00 if pick.get('tier') == 'S' else 0x0099ff
        }
        message["embeds"].append(embed)
    
    # Send to Discord
    try:
        response = requests.post(webhook_url, json=message)
        if response.status_code == 204:
            logger.info("Discord notification sent successfully")
            return True
        else:
            logger.error(f"Discord notification failed: {response.status_code}")
            return False
    except Exception as e:
        logger.error(f"Discord notification exception: {e}")
        return False


def main():
    """Send notifications for latest picks."""
    # Find latest picks file
    picks_dir = Path("reports")
    picks_files = sorted(picks_dir.glob("daily_picks_*.json"), reverse=True)
    
    if not picks_files:
        logger.error("No picks files found. Generate picks first.")
        return 1
    
    latest_picks = str(picks_files[0])
    logger.info(f"Sending notifications for: {latest_picks}")
    
    # Send notifications
    email_sent = send_email_notification(latest_picks)
    discord_sent = send_discord_notification(latest_picks)
    
    if email_sent or discord_sent:
        logger.info("Notifications sent successfully")
        return 0
    else:
        logger.warning("No notifications configured")
        return 1


if __name__ == "__main__":
    sys.exit(main())

